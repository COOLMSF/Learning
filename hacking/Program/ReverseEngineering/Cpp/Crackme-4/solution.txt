Using IDA pro (or readelf) we could list all function that contain 'Password' strings, which seems suspicious:
    PasswordGen::checkPassword(char *)
    PasswordGen::c2(void)
    PasswordGen::c5(void)
    PasswordGen::c7(void)
    PasswordGen::c8(void)
    PasswordGen::c9(void)
    PasswordGen::buildPassword(void)
    PasswordGen::c0(void)
    PasswordGen::c1(void)
    PasswordGen::c3(void)
    PasswordGen::c4(void)
    PasswordGen::c6(void)
    Vault::checkPassword(Void)

From the list above i chose buildPassword. From function name we can guess the purpose of this function is to crate a password
which likely to be compared with our input.

Decompilation result of buildPassword function:
    _BYTE *__fastcall PasswordGen::buildPassword(PasswordGen *this)
    {
      char v1; // dl
      _BYTE *result; // rax

      *(_QWORD *)this = operator new[](0xAuLL);
      **(_BYTE **)this = PasswordGen::c0(this); // store the result of PasswordGen::c0 on index 0
      *(_BYTE *)(*(_QWORD *)this + 1LL) = PasswordGen::c1(this); // store the result of PasswordGen::c1 on index 1
      *(_BYTE *)(*(_QWORD *)this + 2LL) = PasswordGen::c2(this); // store the result of PasswordGen::c2 on index 2
      ...
      *(_BYTE *)(*(_QWORD *)this + 8LL) = PasswordGen::c8(this); // store the result of PasswordGen::c8 on index 8
      v1 = PasswordGen::c9(this); // store the result of PasswordGen::c9 on index 9
      result = (_BYTE *)(*(_QWORD *)this + 9LL);
      *result = v1;
      return result;
    }

From information above, we could clearly see that:
    PasswordGen::c0 is used to generate character at index 0
    PasswordGen::c1 is used to generate character at index 1
    PasswordGen::c2 is used to generate character at index 2
    ...
    PasswordGen::c9 is used to generate character at index 9

Because all of the PasswordGen::cX function is returning a number and the number returned by each function is converted to a character,
we can assume the number is in ASCII format.

To solve problem we need to get all return number of these function, below is all the decompilation result of PasswordGen::cX
    __int64 __fastcall PasswordGen::c0(PasswordGen *this)
    {
      int i; // [rsp+14h] [rbp-4h]

      for ( i = 1; i + 84 <= 32; ++i )
        ;
      return (unsigned int)(i + 84); // return 85
    }

    __int64 __fastcall PasswordGen::c1(PasswordGen *this)
    {
      return 54LL; // return 54
    }

    __int64 __fastcall PasswordGen::c2(PasswordGen *this)
    {
      return (unsigned int)PasswordGen::c1(this) - 9;  // return 45
    }

    __int64 __fastcall PasswordGen::c3(PasswordGen *this)
    {
      return 58LL; // return 58
    }

    __int64 __fastcall PasswordGen::c4(PasswordGen *this)
    {
      int i; // [rsp+24h] [rbp-4h]

      for ( i = 1; i + 88 <= 32; ++i )
        ;
      return (unsigned int)(i + 88); // return 89
    }

    __int64 __fastcall PasswordGen::c5(PasswordGen *this)
    {
      int i; // [rsp+10h] [rbp-8h]
      int v3; // [rsp+14h] [rbp-4h]

      v3 = 1310655;
      for ( i = 1; ; ++i )
      {
        v3 = v3 % 90 + i;
        if ( v3 > 33 )
          break;
      }
      return (unsigned int)v3; // return 76
    }
    __int64 __fastcall PasswordGen::c6(PasswordGen *this)
    {
      int i; // [rsp+14h] [rbp-4h]

      for ( i = 0; i <= 45; ++i )
        ;
      return (unsigned int)i; // return 46
    }

    __int64 __fastcall PasswordGen::c7(PasswordGen *this)
    {
      int v2; // [rsp+24h] [rbp-4h]
      int i; // [rsp+24h] [rbp-4h]

      for ( i = 199292309 % v2; i <= 33 || i > 89; ++i )
        ;
      return (unsigned int)i; // return 34
    }

    __int64 __fastcall PasswordGen::c8(PasswordGen *this)
    {
      return 43LL; // return 43
    }

    __int64 __fastcall PasswordGen::c9(PasswordGen *this)
    {
      return 10LL; // return 10
    }

We get 85,54,45,58,89,76,46,34,43,10 for each index 0 to 9,
i use python code below to convert the number to a character:
    list = [85,54,45,58,89,76,46,34,43,10] # make a list containing all number
    str = "" # create empty string
    for i in list: # loop through all item in list
        str+=chr(i) # convert the number to character, then append it to str variable

    print str # print out str value, which is 'U6-:YL."+\n' without single quotes.

Actually this problem is also solveable using a debugger (i use gdb-peda),
we could see the password on the stack after it return from buildPassword function:
    gdb-peda$ define goo
    Type commands for definition of "goo".
    End with a line saying just "end".
    >break _ZN11PasswordGen13buildPasswordEv
    >run
    >finish
    >end
    gdb-peda$ goo
    Breakpoint 1 at 0x1520

    Please enter the password: hello
    ...
    Breakpoint 1, 0x0000555555555520 in PasswordGen::buildPassword() ()
    [----------------------------------registers-----------------------------------]
    RAX: 0x55555556b699 --> 0xa ('\n')
    RBX: 0x0
    RCX: 0x2e ('.')
    RDX: 0xa ('\n')
    RSI: 0x0
    RDI: 0x7fffffffdfd0 --> 0x55555556b690 ("U6-:YL.\"+\n")  ===========================================================> This is the password
    RBP: 0x7fffffffdfa0 --> 0x7fffffffdfc0 --> 0x7fffffffdff0 --> 0x555555555940 (<__libc_csu_init>:	push   r15)
    RSP: 0x7fffffffdf90 --> 0x7fffffffe0d0 --> 0x1
    RIP: 0x55555555588c (<_ZN5Vault13checkPasswordEv+24>:	mov    rax,QWORD PTR [rbp-0x8])
    R8 : 0x55555556b690 ("U6-:YL.\"+\n") ===============================================================================> also password
    R9 : 0x7ffff7ab5f40 (0x00007ffff7ab5f40)
    R10: 0x20 (' ')
    R11: 0x0
    R12: 0x5555555550b0 (<_start>:	xor    ebp,ebp)
    R13: 0x7fffffffe0d0 --> 0x1
    R14: 0x0
    R15: 0x0
    EFLAGS: 0x206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0x555555555880 <_ZN5Vault13checkPasswordEv+12>:	mov    rax,QWORD PTR [rbp-0x8]
       0x555555555884 <_ZN5Vault13checkPasswordEv+16>:	mov    rdi,rax
       0x555555555887 <_ZN5Vault13checkPasswordEv+19>:	call   0x55555555551c <_ZN11PasswordGen13buildPasswordEv>
    => 0x55555555588c <_ZN5Vault13checkPasswordEv+24>:	mov    rax,QWORD PTR [rbp-0x8]
       0x555555555890 <_ZN5Vault13checkPasswordEv+28>:	mov    rdx,QWORD PTR [rbp-0x8]
       0x555555555894 <_ZN5Vault13checkPasswordEv+32>:	add    rdx,0x8
       0x555555555898 <_ZN5Vault13checkPasswordEv+36>:	mov    rsi,rdx
       0x55555555589b <_ZN5Vault13checkPasswordEv+39>:	mov    rdi,rax
    [------------------------------------stack-------------------------------------]
    0000| 0x7fffffffdf90 --> 0x7fffffffe0d0 --> 0x1
    0008| 0x7fffffffdf98 --> 0x7fffffffdfd0 --> 0x55555556b690 ("U6-:YL.\"+\n") =====================================> also password
    0016| 0x7fffffffdfa0 --> 0x7fffffffdfc0 --> 0x7fffffffdff0 --> 0x555555555940 (<__libc_csu_init>:	push   r15)
    0024| 0x7fffffffdfa8 --> 0x555555555871 (<_ZN5Vault6promptEv+71>:	nop)
    0032| 0x7fffffffdfb0 --> 0x3
    0040| 0x7fffffffdfb8 --> 0x7fffffffdfd0 --> 0x55555556b690 ("U6-:YL.\"+\n")
    0048| 0x7fffffffdfc0 --> 0x7fffffffdff0 --> 0x555555555940 (<__libc_csu_init>:	push   r15)
    0056| 0x7fffffffdfc8 --> 0x5555555558d1 (<main+20>:	mov    eax,0x0)
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    0x000055555555588c in Vault::checkPassword() ()

result: U6-:YL.\"+\n

There's an escape squence on the result ('\') that makes the length more than 10, just remove the '\'.
Final result: U6-:YL."+n

note: All of the decompilation result is using IDA pro.
